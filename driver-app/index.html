<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DeliveryMaster  v50.3.3</title>
    <!-- 
      DeliveryMaster Driver App v50.3.3 (Fixes)
      
      Changelog:
      - v50.3.3 (FIX):
        - Added <meta name="mobile-web-app-capable" content="yes"> to fix deprecation warning.
        - Re-confirming code structure to ensure ISRAEL_CENTER is defined correctly, 
          as user reported 'ISRAEL_CENTER is not defined' error, likely due to cache.
      - v50.3.2 (FIX):
        - Resolved "Cannot access 'DOM' before initialization" error by moving all logic 
          inside the 'DOMContentLoaded' listener.
      - v50.3.1 (FIX):
        - Handled missing driverId/Name gracefully.
        - Removed Service Worker registration.
      - v50.3: Major upgrade - Integrated live map, distance calculation, Firebase backend.
    -->

    <!-- PWA Manifest & Theme -->
    <!-- <link rel="manifest" href="manifest.json"> --> 
    <meta name="theme-color" content="#3a86ff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes"> <!-- FIX: Added for deprecation warning -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/ryPT3r29/image.png">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet Map CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Icons -->
    <script src="https://unpkg.com/feather-icons"></script>

    <style>
        :root {
            --primary-color: #3a86ff; 
            --primary-dark: #2f6ac2;
            --success-color: #28a745;
            --success-dark: #218838;
            --warning-color: #ffc107;
            --warning-dark: #e0a800;
             --danger-color: #dc3545; 
             --danger-dark: #c82333; 
            --bg-light: #f8f9fa; /* slightly lighter gray */
            --bg-white: #ffffff;
            --border-color: #dee2e6; /* lighter border */
            --text-dark: #212529; /* darker text */
            --text-light: #6c757d; /* muted text */
        }
        html, body { height: 100vh; overflow: hidden; } /* Prevent scrolling */
        body { font-family: 'Rubik', sans-serif; overscroll-behavior-y: contain; background-color: var(--bg-light); color: var(--text-dark); }
        
        #map { height: 250px; border-radius: 0.5rem; background-color: #e9ecef; } /* Map placeholder bg */
        .leaflet-control-zoom { display: none; } 
        .leaflet-control-attribution { font-size: 10px; background: rgba(255,255,255,0.7); padding: 1px 4px; border-radius: 2px; }
        .leaflet-popup-content-wrapper { border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .leaflet-popup-content { font-family: 'Rubik', sans-serif; font-size: 0.9rem; line-height: 1.4; }
        .leaflet-popup-content h4 { font-weight: 700; margin-bottom: 5px; font-size: 1rem; }
        .leaflet-popup-content p { margin: 3px 0; color: var(--text-light); }

        /* Buttons */
        .btn { padding: 0.6rem 1rem; border-radius: 0.375rem; /* rounded-md */ font-weight: 500; transition: background-color 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 0.3rem; }
        .btn-primary { background-color: var(--primary-color); color: white; } .btn-primary:hover { background-color: var(--primary-dark); }
        .btn-secondary { background-color: var(--text-light); color: white; } .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: var(--success-color); color: white; } .btn-success:hover { background-color: var(--success-dark); }
        .btn-warning { background-color: var(--warning-color); color: var(--text-dark); } .btn-warning:hover { background-color: var(--warning-dark); }
        .btn-icon { padding: 0.5rem; } 
        .btn-disabled { opacity: 0.6; cursor: not-allowed; pointer-events: none; }

        .notification-card { border-left: 5px solid var(--warning-color); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); } }
        
        /* Loader */
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid var(--primary-color); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Order Card */
        .order-card { background-color: var(--bg-white); border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .order-card h3 { color: var(--text-dark); }
        .order-card .address { color: var(--text-light); }
        .order-card .distance { color: var(--primary-dark); font-weight: 500; }

         /* Status Indicator */
         #status-indicator { font-size: 0.8rem; font-weight: 500; padding: 4px 8px; border-radius: 99px; display: inline-flex; align-items: center; gap: 4px; }
         #status-indicator.connected { background-color: #dcfce7; color: #166534; } /* green */
         #status-indicator.connecting { background-color: #fef9c3; color: #854d0e; } /* yellow */
         #status-indicator.error { background-color: #fee2e2; color: #991b1b; } /* red */
         #status-indicator .dot { width: 6px; height: 6px; border-radius: 50%; }
         #status-indicator.connected .dot { background-color: #22c55e; }
         #status-indicator.connecting .dot { background-color: #facc15; }
         #status-indicator.error .dot { background-color: #ef4444; }
         
         /* Login Error Overlay */
         #login-error-overlay {
             position: fixed; top: 0; left: 0; right: 0; bottom: 0;
             background-color: rgba(255, 255, 255, 0.95);
             z-index: 1000;
             display: none; /* Hidden by default */
             flex-direction: column;
             align-items: center;
             justify-content: center;
             text-align: center;
             padding: 2rem;
         }

    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    <!-- Login Error Overlay -->
    <div id="login-error-overlay">
        <i data-feather="alert-triangle" class="w-16 h-16 text-red-500 mb-4"></i>
        <h2 class="text-2xl font-bold text-red-700 mb-2">砖转 转专转</h2>
        <p class="text-gray-600">  驻专 .</p>
        <p class="text-gray-600 mt-1"> 专 住 专砖 转专 砖.</p>
    </div>


    <!-- Main Container -->
    <div id="main-container" class="container mx-auto max-w-lg p-0 flex flex-col h-screen bg-white shadow-lg">

        <!-- Header -->
        <header class="bg-white shadow-sm p-4 flex justify-between items-center sticky top-0 z-10 border-b border-gray-200">
            <div>
                <h1 class="text-xl font-bold text-gray-800">DeliveryMaster</h1>
                <p id="driver-name-display" class="text-sm text-gray-600">: 注...</p>
            </div>
            <div id="status-indicator" class="connecting">
                 <span id="status-text">注...</span>
                 <span id="status-dot" class="dot"></span>
            </div>
        </header>

        <!-- Permission Request Area -->
        <div id="permission-section" class="p-4 space-y-3 bg-yellow-100 border-b border-yellow-300" style="display: none;"> 
             <p class="text-sm font-medium text-yellow-800">专砖转 专砖转 拽 转专转:</p>
             <button id="request-perms-btn" class="w-full text-sm btn btn-warning">拽砖 专砖转</button>
        </div>

        <!-- Info & Map Area -->
        <div class="p-4 border-b border-gray-200">
            <div id="location-info" class="bg-blue-50 p-3 rounded-lg mb-3 text-sm text-blue-800">
                 <p id="current-location-text"> 转专 拽 ...</p>
                 <p id="eta-text" class="mt-1 font-medium hidden">...</p> <!-- ETA display -->
            </div>
            <div id="map"></div>
        </div>

        <!-- Order List -->
        <main id="order-list" class="flex-grow overflow-y-auto p-4 space-y-4 bg-gray-50">
             <div id="loading-orders" class="text-center py-10 text-gray-500">
                 <div class="loader mx-auto mb-2"></div>
                 注 砖转...
             </div>
             <!-- Order cards dynamically inserted here -->
        </main>

    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Tone.js for Sound -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>


    <!-- Combined & Inlined App Logic -->
    <script type="module">
        console.log('Driver App script started (v50.3.2)'); // v50.3.2

        // --- Inlined Firebase SDK Imports ---
        import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, collection, doc, onSnapshot, query, addDoc, updateDoc, serverTimestamp, where, setDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js"; 

        // --- Inlined Config Logic ---
        const firebaseConfig = { /* ... config object ... */
            apiKey: "AIzaSyDq0oVwS6zbEfsgrYBRkeBq80dDUKMedzo", authDomain: "saban94-78949.firebaseapp.com", projectId: "saban94-78949",
            storageBucket: "saban94-78949.firebasestorage.app", messagingSenderId: "41553157903", appId: "1:41553157903:web:cc33d252cff023be97a87a", measurementId: "G-XV6RZDESSB"
        };
        let app, auth, db; let initializationError = null;
        try {
            app = getApps().length ? getApp() : initializeApp(firebaseConfig); console.log("Firebase app instance ensured.");
            auth = getAuth(app); db = getFirestore(app);
        } catch (error) { console.error("CRITICAL: Firebase init failed!", error); initializationError = error; }

        const MAX_AUTH_RETRIES = 3; const RETRY_DELAY_MS = 3000;
        async function ensureAuth() { 
            console.log("ensureAuth: Starting..."); let tries = 0;
            // *** MOVED updateStatus calls to initializeDriverApp ***
            while (tries < MAX_AUTH_RETRIES) {
                tries++;
                try {
                    if (initializationError) throw new Error(`Init failed: ${initializationError.message}`);
                    if (!auth) throw new Error("Auth object missing");
                    console.log(`ensureAuth: Attempt ${tries}/${MAX_AUTH_RETRIES}...`);
                    const userCredential = await signInAnonymously(auth);
                    console.log("ensureAuth: Success.", userCredential.user.uid); 
                    return userCredential.user;
                } catch (e) {
                    console.warn(`[FirebaseAuth] Attempt ${tries} failed:`, e.code, e.message);
                    if (tries >= MAX_AUTH_RETRIES) { console.error("ensureAuth: All attempts failed."); throw e; }
                    console.log(`ensureAuth: Retrying in ${RETRY_DELAY_MS / 1000}s...`); await new Promise(r => setTimeout(r, RETRY_DELAY_MS));
                }
            } throw new Error("ensureAuth: Max retries reached.");
        }
        const authReadyPromise = ensureAuth(); // Call immediately
        console.log("Config part executed.");

        // --- Inlined SmartLog Logic ---
        const LOG_COLLECTION = 'system_logs_v3'; const sessionId = (Date.now() + Math.random()).toString(36);
        let isDbAvailable = !!db; let isAuthReadyForLogging = false; 
        authReadyPromise.then(() => { isAuthReadyForLogging = true; console.log("SmartLog: Auth is ready for logging."); })
                      .catch(() => { console.warn("SmartLog: Auth failed, Firestore logging disabled."); isDbAvailable = false; }); 

        const writeLog = async (level, message, origin, context = {}, category = null, solution = null) => {
             const consoleArgs = [`[${origin}] ${level}:`, message]; if (Object.keys(context).length > 0) consoleArgs.push(context); /* ... */
            switch (level) { case 'INFO': console.log(...consoleArgs); break; case 'WARN': console.warn(...consoleArgs); break; case 'ERROR': console.error(...consoleArgs); break; default: console.log(...consoleArgs); }
            if (!isDbAvailable || !isAuthReadyForLogging) { return; } 
            try {
                const user = auth?.currentUser; if (!user) { return; }
                const userContext = { uid: user.uid, isAnonymous: user.isAnonymous };
                const logEntry = {
                    timestamp: serverTimestamp(), level, message: String(message), origin: `Driver-${origin}`, // Prefix origin
                    context: { ...JSON.parse(JSON.stringify(context || {})), sessionId, userAgent: navigator.userAgent || 'N/A', page: '/driver-app/' },
                    user: userContext, category: category || null, solution: solution || null
                };
                 // Fire and forget log for driver app
                 addDoc(collection(db, LOG_COLLECTION), logEntry).catch(e => console.error("Driver SmartLog write error:", e));
            } catch (error) { console.error("Driver SmartLog FATAL ERROR.", error); if (error.code === 'permission-denied') { console.warn("Driver SmartLog: Disabling Firestore logging."); isDbAvailable = false; } }
         };
        const SmartLog = {
            info: (msg, origin, ctx = {}) => { writeLog('INFO', msg, origin, ctx); },
            warn: (msg, origin, ctx = {}, cat = null, sol = null) => { writeLog('WARN', msg, origin, ctx, cat, sol); },
            error: (err, origin, ctx = {}, cat = null, sol = null) => { const msg = err instanceof Error ? err.message : String(err); const stack = err instanceof Error ? err.stack : 'N/A'; writeLog('ERROR', msg, origin, { ...ctx, stack }, cat, sol); }
        };
        console.log("SmartLog part executed.");


        // --- Driver App Specific Logic ---

        // Globals
        let map; 
        let driverMarker = null; // Marker for the driver
        let orderMarkers = {}; // Object to hold order markers { orderId: markerInstance }
        let currentDriverId = localStorage.getItem('driverId');
        let currentDriverName = localStorage.getItem('driverName');
        let watchId = null; 
        let currentOrders = []; // Array of assigned, active orders
        let currentLatLng = null; // Driver's current location [lat, lng]
        let notificationAudio = null;
        let hasNotificationPermission = false; 
        let hasGeolocationPermission = false;
        let lastLocationUpdate = 0;
        const LOCATION_UPDATE_INTERVAL = 20000; // 20 seconds
        const ACTIVE_DRIVER_ORDER_STATUSES = ["砖", "专"]; // Statuses relevant for the driver map/list

        // *** FIX: ISRAEL_CENTER was missing. It's defined here now. ***
        const ISRAEL_CENTER = [32.0853, 34.7818];

        // DOM Elements 
        let DOM = {}; // *** DECLARED here, POPULATED in initializeDriverApp ***

        // --- Initialization ---
        async function initializeDriverApp() {
            try { 
                // *** DOM assignment MUST be first ***
                DOM = {
                     driverNameDisplay: document.getElementById('driver-name-display'), 
                     statusIndicator: document.getElementById('status-indicator'), // Main indicator div
                     statusText: document.getElementById('status-text'), 
                     statusDot: document.getElementById('status-dot'),
                     permissionSection: document.getElementById('permission-section'), 
                     requestPermsBtn: document.getElementById('request-perms-btn'), 
                     locationInfo: document.getElementById('location-info'),
                     currentLocationText: document.getElementById('current-location-text'), 
                     etaText: document.getElementById('eta-text'), 
                     mapElement: document.getElementById('map'), 
                     orderList: document.getElementById('order-list'), 
                     loadingOrders: document.getElementById('loading-orders'),
                     loginErrorOverlay: document.getElementById('login-error-overlay'), // Error overlay
                     mainContainer: document.getElementById('main-container') // Main content container
                };
                SmartLog.info("DOM elements referenced.", "Init.DOM");
                
                // Check for essential elements *after* defining them
                if (!DOM.driverNameDisplay || !DOM.statusIndicator || !DOM.mapElement || !DOM.orderList || !DOM.loginErrorOverlay || !DOM.mainContainer) {
                     throw new Error("Essential DOM elements missing!"); 
                }
    
                SmartLog.info("Initializing Driver App (v50.3.2)...", "Init");
                
                // Now safe to update status
                updateStatus("connecting", "转..."); 

                // Check for saved driver ID FIRST
                if (!currentDriverId || !currentDriverName) {
                    SmartLog.error(new Error("Missing driverId/Name"), "Auth", null, "Auth", "  专.");
                    showLoginErrorOverlay(); // Show the overlay instead of redirecting
                    return; // Stop initialization
                }
                DOM.driverNameDisplay.textContent = `: ${currentDriverName}`; // Moved here

                await authReadyPromise;
                SmartLog.info("Firebase Auth Ready.", "Init");
                updateStatus("connecting", "拽 专砖转..."); // Moved from ensureAuth

                await checkAndRequestPermissions(); 

                updateStatus("connecting", "转 驻...");
                initMap(); // This should now work as ISRAEL_CENTER is defined

                if (hasGeolocationPermission) {
                    updateStatus("connecting", "驻注 GPS...");
                    startGeolocation();
                } else {
                     updateStatus("error", "转 砖专 拽");
                     SmartLog.warn("Geolocation permission pending/denied. GPS not started.", "Permissions");
                }

                 initNotifications();

                updateStatus("connecting", "住专 砖转...");
                listenToOrders();

                updateFinalStatus(); // Set initial status based on permissions/GPS

                SmartLog.info("Driver App Initialization Complete.", "Init");

            } catch (error) {
                SmartLog.error(error, "Init.Critical");
                // Check if DOM is initialized before trying to use it
                if (DOM.statusIndicator) {
                    updateStatus("error", `砖转 转`);
                }
                showLoginErrorOverlay(`砖转 转: ${error.message}`); // Show overlay on critical init error
            }
        }

        // --- Login Error Handling ---
        function showLoginErrorOverlay(message = "  驻专 .") {
             // Check if DOM object and its properties are populated
             if (DOM && DOM.loginErrorOverlay && DOM.mainContainer) {
                 const messageParagraphs = DOM.loginErrorOverlay.querySelectorAll('p');
                 if (messageParagraphs.length > 0) messageParagraphs[0].textContent = message;
                 if (messageParagraphs.length > 1) messageParagraphs[1].textContent = " 专 住 专砖 转专 砖.";
                 
                 DOM.loginErrorOverlay.style.display = 'flex';
                 DOM.mainContainer.style.display = 'none'; // Hide the main app content
                 try { if(feather) feather.replace(); } catch(e){} // Redraw icon in overlay
             } else {
                 // Fallback if DOM elements aren't ready (which caused the error)
                 console.error("Login Error Overlay failed to display, DOM not ready.", message);
                 alert(message + "\n 专 住 专砖 转专 砖.");
             }
         }


         function updateFinalStatus() {
             if (watchId) {
                 updateStatus("connected", "GPS 驻注");
             } else if (!hasGeolocationPermission) {
                 updateStatus("error", "专砖转 专砖转 拽");
             } else {
                 updateStatus("connecting", "GPS  驻注"); // Use 'connecting' style for non-critical issues
             }
         }

        // --- Status Update ---
        function updateStatus(statusClass, text) { // Simplified args
             if (!DOM.statusIndicator || !DOM.statusText || !DOM.statusDot) { 
                 console.warn("Status elements not ready for update (called too early or elements missing):", text); 
                 return; 
             }
             SmartLog.info(`Updating Status: ${text}`, "UI.Status", { class: statusClass });
             DOM.statusIndicator.className = statusClass; // 'connecting', 'connected', 'error'
             DOM.statusText.textContent = text;
        }

        // --- Permissions ---
        async function checkAndRequestPermissions() { /* ... implementation mostly unchanged, ensure it uses DOM ... */
             SmartLog.info("Checking permissions...", "Permissions");
             let needsGeoRequest = false;
             let needsNotifRequest = false;

             try {
                const geoStatus = await navigator.permissions.query({ name: 'geolocation' });
                hasGeolocationPermission = geoStatus.state === 'granted';
                if (geoStatus.state === 'prompt') needsGeoRequest = true;
                SmartLog.info("Geolocation status:", "Permissions", { status: geoStatus.state });
             } catch (e) { SmartLog.warn("Could not query geo permission.", "Permissions", e); needsGeoRequest = true; }

             if ('Notification' in window) {
                hasNotificationPermission = Notification.permission === 'granted';
                if (Notification.permission === 'default') needsNotifRequest = true;
                SmartLog.info("Notification status:", "Permissions", { status: Notification.permission });
             } else { SmartLog.warn("Notifications not supported.", "Permissions"); }

             if (needsGeoRequest || needsNotifRequest) {
                 if (DOM.permissionSection && DOM.requestPermsBtn) {
                     DOM.permissionSection.style.display = 'block';
                     DOM.requestPermsBtn.removeEventListener('click', handlePermissionRequest); 
                     DOM.requestPermsBtn.addEventListener('click', handlePermissionRequest);
                     updateStatus("error", "专砖转 专砖转"); // Use error style for pending permissions
                 } else { SmartLog.error("Permission UI elements not found!", "Permissions"); }
             } else {
                 if (DOM.permissionSection) DOM.permissionSection.style.display = 'none';
                 SmartLog.info("Permissions already handled.", "Permissions");
             }
        }

        async function handlePermissionRequest() { /* ... implementation mostly unchanged ... */
             SmartLog.info("Requesting permissions via button click...", "Permissions");
            let geoGranted = hasGeolocationPermission;
            let notifGranted = hasNotificationPermission;

            // Request Geolocation
            if (!hasGeolocationPermission) {
                try {
                    await new Promise((resolve, reject) => { 
                        navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 15000, enableHighAccuracy: true }); 
                    });
                    const geoStatus = await navigator.permissions.query({ name: 'geolocation' });
                    geoGranted = geoStatus.state === 'granted';
                    hasGeolocationPermission = geoGranted;
                    SmartLog.info("Geolocation request result:", "Permissions", { status: geoStatus.state });
                    if(geoGranted && !watchId) {
                        updateStatus("connecting", "驻注 GPS...");
                        startGeolocation(); // Start immediately after grant
                    }
                 } catch (e) { SmartLog.error(e, "Permissions", { message: "Geolocation request failed." }); }
            }

            // Request Notifications
            if ('Notification' in window && Notification.permission === 'default') {
                try {
                    const permission = await Notification.requestPermission();
                    notifGranted = permission === 'granted';
                    hasNotificationPermission = notifGranted;
                    SmartLog.info("Notification request result:", "Permissions", { status: permission });
                     if(notifGranted) initNotifications();
                } catch (e) { SmartLog.error(e, "Permissions", { message: "Notification request failed." }); }
            }

            if (geoGranted) { 
                if (DOM.permissionSection) DOM.permissionSection.style.display = 'none';
                updateFinalStatus(); // Update status based on potentially new GPS state
            } else {
                 updateStatus("error", "专砖转 专砖转 拽!");
                 if (DOM.requestPermsBtn) {
                    DOM.requestPermsBtn.textContent = "拽砖 专砖转 拽 砖";
                    DOM.requestPermsBtn.classList.add('btn-disabled');
                    setTimeout(() => {
                         if(DOM.requestPermsBtn) DOM.requestPermsBtn.classList.remove('btn-disabled');
                    }, 5000);
                 }
            }
        }

        // --- Geolocation & Location Update ---
        function startGeolocation() { 
            if (watchId) { SmartLog.info("Geolocation already watching.", "GPS"); return; }
            if (!hasGeolocationPermission) { SmartLog.warn("Cannot start GPS, permission not granted.", "GPS"); updateStatus("error", "专砖转 专砖转 拽"); return; }
            if (!('geolocation' in navigator)) { SmartLog.error("Geolocation not supported.", "GPS"); updateStatus("error", "GPS  转"); return; }

            SmartLog.info("Starting geolocation watchPosition...", "GPS");
            updateStatus("connecting", "驻注 GPS...");

            watchId = navigator.geolocation.watchPosition(
                async (position) => {
                    const { latitude, longitude, accuracy } = position.coords;
                    currentLatLng = [latitude, longitude]; // Store current location
                    SmartLog.info("GPS Update Received", "GPS", { lat: latitude, lon: longitude, acc: accuracy });
                    updateStatus("connected", "GPS 驻注");
                    updateDriverMarkerOnMap(latitude, longitude);
                    updateLocationText(latitude, longitude);
                    updateDistances(); // Update distances on cards and potentially map popups
                    updateMapBounds(); // Adjust map view

                    const now = Date.now();
                    if (now - lastLocationUpdate > LOCATION_UPDATE_INTERVAL) { 
                        SmartLog.info("Sending location update to Firestore...", "GPS.Firestore");
                        await updateLocationInFirestore(latitude, longitude);
                        lastLocationUpdate = now;
                    }
                },
                (error) => {
                    SmartLog.error(error, "GPS.Error");
                    currentLatLng = null; // Clear location on error
                    let errorMsg = "砖转 GPS"; if (error.code === 1) errorMsg = "GPS:  专砖"; else if (error.code === 2) errorMsg = "GPS:  "; else if (error.code === 3) errorMsg = "GPS: Timeout";
                    updateStatus("error", errorMsg);
                    if(watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
                },
                { enableHighAccuracy: true, timeout: 20000, maximumAge: 10000 } // Adjusted timeouts
            );
        }
        async function updateLocationInFirestore(lat, lng) { 
             if (!db || !currentDriverId) return; 
             const locationRef = doc(db, "driverLocations", currentDriverId);
             const locationData = { 
                 latitude: lat, 
                 longitude: lng, 
                 lastUpdate: serverTimestamp(),
                 driverName: currentDriverName // Keep name updated
             };
             try { 
                 // Use setDoc with merge: true to create if not exists, or update if exists
                 await setDoc(locationRef, locationData, { merge: true }); 
                 SmartLog.info("Location updated/set in Firestore.", "GPS.Firestore");
             } catch (e) { 
                 SmartLog.error(e, "GPS.Firestore.Set"); 
             } 
        }
        async function updateLocationText(lat, lng) { /* ... implementation unchanged ... */
            if (!DOM.currentLocationText) return; DOM.currentLocationText.textContent = ` ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
            try { const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16`); if (!response.ok) throw new Error(`${response.status}`); const data = await response.json(); if (data?.display_name) { const parts = data.display_name.split(', '); const short = parts.slice(0, 3).join(', '); DOM.currentLocationText.textContent = ` ${short}`; SmartLog.info("Reverse geocode success", "GPS.Geo", { address: short }); } else { SmartLog.warn("Reverse geocode failed: No display_name", "GPS.Geo", { data }); } } catch (error) { SmartLog.error(error, "GPS.ReverseGeocode"); }
        }

        // --- Map Handling ---
        function initMap() { 
             try { 
                 if (map) map.remove(); // Remove existing map if any
                 map = L.map(DOM.mapElement).setView(ISRAEL_CENTER, 13); // *** USES ISRAEL_CENTER ***
                 L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                     attribution: '&copy; OSM', 
                     maxZoom: 18, 
                 }).addTo(map); 
                 SmartLog.info("Map initialized", "Map"); 
             } catch (e) { 
                 SmartLog.error(e, "Map.Init"); 
                 if (DOM.mapElement) DOM.mapElement.innerHTML = '<p class="text-red-500 p-4 text-center">Map Error</p>'; 
             }
        }
        
        function updateDriverMarkerOnMap(lat, lng) { 
             if (!map) return; 
             const latLng = [lat, lng]; 
             if (driverMarker) { 
                 driverMarker.setLatLng(latLng); 
             } else { 
                 // Driver Marker Style (Blue circle)
                 driverMarker = L.circleMarker(latLng, { 
                     radius: 8, 
                     fillColor: "#3a86ff", // Blue
                     color: "#fff", // White border
                     weight: 2, 
                     opacity: 1, 
                     fillOpacity: 0.9 
                 }).addTo(map); 
                 driverMarker.bindPopup(`<b>${currentDriverName}</b> (拽 )`);
                 SmartLog.info("Driver marker added", "Map"); 
             } 
             // Don't pan here, let updateMapBounds handle it
        }

        function updateOrderMarkersOnMap() {
            if (!map) return;

            const activeMapOrders = currentOrders.filter(o => o.latitude && o.longitude);

            // Remove markers for orders no longer in the active list
            Object.keys(orderMarkers).forEach(orderId => {
                if (!activeMapOrders.some(o => o.id === orderId)) {
                    if (map.hasLayer(orderMarkers[orderId])) {
                        map.removeLayer(orderMarkers[orderId]);
                    }
                    delete orderMarkers[orderId];
                }
            });

            // Add/Update markers for current active orders
            activeMapOrders.forEach(order => {
                const latLng = [order.latitude, order.longitude];
                const distanceText = currentLatLng ? `专拽: ${(L.latLng(currentLatLng).distanceTo(latLng) / 1000).toFixed(1)} 拽"` : '砖 专拽...';
                const popupContent = `
                    <h4>${order.customer?.name || '?'}</h4>
                    <p>${order.address || '?'}</p>
                    <p>${distanceText}</p>
                    <p>住住: ${order.status}</p>`;

                if (orderMarkers[order.id]) {
                    orderMarkers[order.id].setLatLng(latLng).setPopupContent(popupContent);
                } else {
                    orderMarkers[order.id] = L.marker(latLng, { icon: orderIconActive }) // Use blue icon for orders
                        .addTo(map)
                        .bindPopup(popupContent);
                    SmartLog.info("Order marker added", "Map", { orderId: order.id });
                }
            });

            updateMapBounds(); // Adjust bounds after updating markers
        }
        
        // Adjust map view to fit driver and active orders
        function updateMapBounds() {
            if (!map) return;
            const bounds = L.latLngBounds();
            
            if (driverMarker) {
                 bounds.extend(driverMarker.getLatLng());
            }
            Object.values(orderMarkers).forEach(marker => {
                 bounds.extend(marker.getLatLng());
            });

            if (bounds.isValid()) {
                 map.fitBounds(bounds, { padding: [40, 40], maxZoom: 16 }); 
            } else if (driverMarker) {
                 map.setView(driverMarker.getLatLng(), 15); // Center on driver if no orders
            } else {
                map.setView(ISRAEL_CENTER, 13); // Default view if nothing to show
            }
        }

        // --- Order Handling ---
        function listenToOrders() { 
             SmartLog.info("Listening to orders:", "Orders", { driverId: currentDriverId }); 
             // Query for orders assigned to this driver with relevant statuses
             const q = query( 
                 collection(db, "orders"), 
                 where("driver.id", "==", currentDriverId), 
                 where("status", "in", ACTIVE_DRIVER_ORDER_STATUSES) 
                 // Consider adding orderBy('createdAt', 'asc') if needed, might require index
             );
             
             onSnapshot(q, (snapshot) => { 
                 SmartLog.info(`Orders snapshot: ${snapshot.docChanges().length} changes`, "Orders"); 
                 if (DOM.loadingOrders) DOM.loadingOrders.style.display = 'none'; 
                 let newOrderDetected = false;
                 
                 // Process changes more efficiently
                 snapshot.docChanges().forEach((change) => { 
                     const orderId = change.doc.id; 
                     const orderData = { id: orderId, ...change.doc.data() };
                     
                     if (change.type === "added") { 
                         SmartLog.info("New order added to list:", "Orders", { orderId }); 
                         currentOrders.push(orderData); // Add to array
                         if (orderData.status === '砖') newOrderDetected = true; 
                     } else if (change.type === "modified") { 
                         SmartLog.info("Order modified:", "Orders", { orderId, status: orderData.status }); 
                         // Find and update the order in the array
                         const index = currentOrders.findIndex(o => o.id === orderId);
                         if (index > -1) currentOrders[index] = orderData;
                         else currentOrders.push(orderData); // Or add if somehow missing
                     } else if (change.type === "removed") { 
                         SmartLog.info("Order removed from list:", "Orders", { orderId }); 
                         // Filter out the removed order
                         currentOrders = currentOrders.filter(o => o.id !== orderId);
                     } 
                 });
                 
                 renderOrderList(); // Update the list display
                 updateOrderMarkersOnMap(); // Update markers on the map
                 
                 if (newOrderDetected) handleNewOrderNotification();
                 
             }, (error) => { 
                 SmartLog.error(error, "Orders.Listener"); 
                 updateStatus("error", "砖转 住专"); 
                 if (DOM.loadingOrders) DOM.loadingOrders.innerHTML = '<p class="text-red-500">砖转 住专</p>'; 
             });
        }
        
        // Rerenders the entire order list
        function renderOrderList() { 
             // Sort orders: '砖' first, then by creation time maybe? Or distance? Let's stick to status first.
             currentOrders.sort((a, b) => {
                 if (a.status === '砖' && b.status !== '砖') return -1;
                 if (a.status !== '砖' && b.status === '砖') return 1;
                 // Optional: sort by createdAt if statuses are the same
                 return (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0); 
             }); 
             
             if (!DOM.orderList) return;
             
             if (currentOrders.length === 0) { 
                 DOM.orderList.innerHTML = `<p class="text-center text-gray-500 py-10"> 砖转 驻注转.</p>`; 
                 updateOrderMarkersOnMap(); // Clear markers if list is empty
                 return; 
             }
             
             DOM.orderList.innerHTML = currentOrders.map(order => createOrderCard(order)).join(''); 
             updateDistances(); // Update distances after rendering
             try{ if(feather) feather.replace(); } catch(e){} // Redraw icons
        }

        // Updates distance text on existing order cards
        function updateDistances() {
             if (!currentLatLng) return; // Need driver location
             
             currentOrders.forEach(order => {
                 const card = document.getElementById(`order-${order.id}`);
                 const distEl = card?.querySelector('.distance'); // Target the specific distance span
                 if (distEl && order.latitude && order.longitude) {
                     try {
                        const orderLatLng = L.latLng(order.latitude, order.longitude);
                        const driverLatLng = L.latLng(currentLatLng);
                        const distanceKm = (driverLatLng.distanceTo(orderLatLng) / 1000).toFixed(1);
                        distEl.textContent = ` ${distanceKm} 拽"`;
                     } catch (e) {
                         console.warn("Error calculating distance for order", order.id, e);
                         distEl.textContent = ` - 拽"`;
                     }
                 } else if (distEl) {
                     distEl.textContent = ` - 拽"`; // No coords for order
                 }
                 
                 // Update map popup distance if open
                 const marker = orderMarkers[order.id];
                 if (marker && marker.isPopupOpen()) {
                      const distanceText = `专拽: ${(L.latLng(currentLatLng).distanceTo([order.latitude, order.longitude]) / 1000).toFixed(1)} 拽"`;
                      const popupContent = `<h4>${order.customer?.name || '?'}</h4><p>${order.address || '?'}</p><p>${distanceText}</p><p>住住: ${order.status}</p>`;
                      marker.setPopupContent(popupContent);
                 }
             });
        }

        function createOrderCard(order) { 
            let cardClass = "order-card bg-white p-4 rounded-lg shadow"; 
            let actionButton = ''; 
            let statusText = order.status || '?'; 
            let statusColor = "text-gray-500";
            let distanceText = '砖 专拽...'; // Default distance text

             if (currentLatLng && order.latitude && order.longitude) {
                  try {
                     const orderLatLng = L.latLng(order.latitude, order.longitude);
                     const driverLatLng = L.latLng(currentLatLng);
                     distanceText = ` ${(driverLatLng.distanceTo(orderLatLng) / 1000).toFixed(1)} 拽"`;
                  } catch(e) { distanceText = '砖转 专拽'; }
             }

            switch (order.status) {
                case '砖': 
                    cardClass += " notification-card"; 
                    statusText = "砖 - 砖专"; 
                    statusColor = "text-yellow-600 font-bold"; 
                    actionButton = `<button class="w-full btn btn-success mt-3" onclick="window.acknowledgeOrder('${order.id}')"><i data-feather="check-circle" class="inline w-4 h-4 ml-1"></i> 砖专 转转 注住</button>`; 
                    break;
                // Removed '转 拽' as it's not in ACTIVE_DRIVER_ORDER_STATUSES
                // case '转 拽': 
                //     statusText = "注住"; statusColor = "text-blue-600"; 
                //     actionButton = `<p class="text-center text-sm text-gray-500 italic mt-3">转 住 注住...</p>`; 
                //     break; 
                case '专': 
                    statusText = "专 拽"; 
                    statusColor = "text-green-600 font-semibold"; 
                    actionButton = `<button class="w-full btn btn-success mt-3" onclick="window.completeOrder('${order.id}')"><i data-feather="flag" class="inline w-4 h-4 ml-1"></i> 住 砖</button>`; 
                    break;
                default: 
                    cardClass += " opacity-70"; // Should not happen with current filter
            }
            
            // Generate Google Maps link
            const mapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${order.latitude},${order.longitude}`; // Use lat,lon for more accuracy
            
            const buttons = `<div class="grid grid-cols-2 gap-2 mt-3 text-sm">
                                <a href="tel:${order.customer?.phone || ''}" class="btn btn-secondary btn-sm"><i data-feather="phone" class="inline w-4 h-4"></i> 拽</a>
                                <a href="${mapsUrl}" target="_blank" class="btn btn-primary btn-sm"><i data-feather="navigation" class="inline w-4 h-4"></i> </a>
                             </div>`;
            
            return `<div class="${cardClass}" id="order-${order.id}">
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                <h3 class="text-lg font-bold text-gray-900">${order.customer?.name || '?'}</h3>
                                <p class="text-sm text-gray-600 address">${order.address || '?'}</p>
                                <span class="text-sm distance">${distanceText}</span> 
                            </div>
                            <span class="text-xs font-medium ${statusColor} whitespace-nowrap">${statusText}</span>
                        </div>
                        <p class="text-xs text-gray-500 mb-3">注专转: ${order.notes || ''}</p>
                        ${actionButton}
                        ${buttons}
                    </div>`;
        }

        // --- Order Actions ---
        window.acknowledgeOrder = async (orderId) => { 
            SmartLog.info("Acknowledging order...", "Orders.Action", { orderId }); 
            const button = document.querySelector(`#order-${orderId} button`);
             if(button) button.classList.add('btn-disabled'); // Disable button visually
            try { 
                const orderRef = doc(db, "orders", orderId); 
                // Change status to '专' directly, skipping '转 拽'
                await updateDoc(orderRef, { status: "专", lastModified: serverTimestamp() }); 
                SmartLog.info("Status updated to '专'", "Orders.Action", { orderId }); 
                stopNotificationSound(); 
                document.getElementById(`order-${orderId}`)?.classList.remove('notification-card'); 
            } catch (e) { 
                SmartLog.error(e, "Orders.Action.Acknowledge"); 
                alert("砖 砖专."); 
                 if(button) button.classList.remove('btn-disabled'); // Re-enable on error
            }
            // Listener will handle re-render
        };
        
        window.completeOrder = async (orderId) => { 
             SmartLog.info("Completing order...", "Orders.Action", { orderId }); 
             if (!confirm("住 砖 砖?")) return; 
             const button = document.querySelector(`#order-${orderId} button`);
             if(button) button.classList.add('btn-disabled');
             try { 
                 const orderRef = doc(db, "orders", orderId); 
                 await updateDoc(orderRef, { status: "砖", completedAt: serverTimestamp(), lastModified: serverTimestamp() }); 
                 SmartLog.info("Status updated to '砖'", "Orders.Action", { orderId }); 
                 // Order will disappear from the list automatically due to the listener filter
             } catch (e) { 
                 SmartLog.error(e, "Orders.Action.Complete"); 
                 alert("砖 住."); 
                 if(button) button.classList.remove('btn-disabled');
             }
        };

        // --- Notifications ---
        function initNotifications() { /* ... implementation unchanged ... */
             if (!hasNotificationPermission || !window.Tone) return; try { notificationAudio = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(); SmartLog.info("Audio initialized.", "Notifications"); } catch (e) { SmartLog.error(e, "Notifications.InitAudio"); }
        }
        function handleNewOrderNotification() { /* ... implementation unchanged ... */
             SmartLog.info("New order notification...", "Notifications");
             if (notificationAudio && Tone?.context?.state === 'running') { try { notificationAudio.triggerAttackRelease("C5", "8n", Tone.now()); notificationAudio.triggerAttackRelease("G5", "8n", Tone.now() + 0.2); SmartLog.info("Sound played.", "Notifications"); } catch(e) { SmartLog.error(e, "Notifications.PlaySound"); } }
             else if (notificationAudio) { Tone.start().then(() => { SmartLog.info("Audio context resumed. Retrying sound.", "Notifications"); try { notificationAudio.triggerAttackRelease("C5", "8n", Tone.now()); notificationAudio.triggerAttackRelease("G5", "8n", Tone.now() + 0.2); } catch(e) { SmartLog.error(e, "Notifications.PlaySoundRetry"); } }).catch(e => SmartLog.error(e, "Notifications.ToneStartFailed")); }
             else { SmartLog.warn("Cannot play sound.", "Notifications"); }
             if (hasNotificationPermission && 'Notification' in window) { const notification = new Notification(" 砖!", { body: "砖 砖 转 砖专.", icon: "https://i.postimg.cc/ryPT3r29/image.png", vibrate: [200, 100, 200] }); notification.onclick = () => { window.focus(); SmartLog.info("Notification clicked.", "Notifications"); }; SmartLog.info("Browser notification shown.", "Notifications"); }
             else { SmartLog.warn("Cannot show browser notification.", "Notifications"); }
        }
        function stopNotificationSound() { /* ... implementation unchanged ... */
             SmartLog.info("Stopping sound (placeholder).", "Notifications");
        }

        // --- Service Worker Registration ---
        // function registerServiceWorker() { /* ... REMOVED ... */ }


        // --- Start Application ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired (v50.3.2). Starting app initialization...'); 
            
            // Initialize SmartLog fallback *early* in case of errors
            if (typeof SmartLog === 'undefined') {
                console.error("SmartLog failed to initialize. Using console fallback.");
                 window.SmartLog = { info: console.log, warn: console.warn, error: console.error };
            }
            
            SmartLog.info("DOMContentLoaded fired.", "Init");
            // registerServiceWorker(); // REMOVED
            
            // *** MOVED ALL LOGIC INSIDE DOMContentLoaded ***
            initializeDriverApp(); 
            
             try { 
                 if(feather) {
                     feather.replace(); 
                 } else {
                     SmartLog.warn("Feather icons not loaded, trying again in 500ms", "UI");
                     setTimeout(() => { 
                         try { feather.replace(); } catch(e) { SmartLog.error(e, "UI", { message: "Feather retry failed" }); }
                     }, 500);
                 }
             } catch (e) { 
                 SmartLog.error(e, "UI", { message: "Feather icons replace failed on init." }); 
             }
        });

    </script>

</body>
</html>
